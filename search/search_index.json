{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":""},{"location":"index.html#intelligent-tutoring-system-its-of-programming-education","title":"Intelligent Tutoring System (ITS) of Programming Education","text":"Figure 1: General idea of an ITS that supports students and tutors in programming courses."},{"location":"index.html#motivation","title":"Motivation","text":"<p>In Computer Science (CS) education, we face the challenge of increasing student enrollments over the past few years. Consequently, it has become increasingly difficult to provide high-quality and individualized learning support, particularly for novice students. Mirhosseini et al. recently conducted an interview study with CS instructors to identify their biggest pain points. Among other issues, they found that CS instructors struggle with limited or no Teaching Assistant (TA) support and the generally time-consuming task of providing student feedback and grading assignments. Thus, CS instructors would greatly benefit from automating tutoring activities to support TAs in their responsibilities.</p>"},{"location":"index.html#development","title":"Development","text":"<p>Intelligent Tutoring System (ITS) of Programming Education is a fully automated tutoring system developed at the Trustworthy and Secure Software Lab of the National University of Singapore (NUS) that aims to provide on-time personalized feedback to students and grading support to tutors/instructors for programming assignments in Computer Science (CS) courses. It is a language-independent system that can be used with any programming language (e.g., Python, Java, C, etc.). It supports various functionalities, including syntax error fixing, logical error localization / repairing, and programming conceptual automated grading. Notably, the ITS is tightly coupled with the advanced large language models (LLMs) to provide high-level natural language feedback to students. The ITS has been used in CS1010S and CS2040S at NUS.</p>"},{"location":"index.html#general-idea","title":"General Idea","text":"<p>Figure 1 illustrates the general concept of the Intelligent Tutoring System. The lecturer provides reference programs and test cases as specifications of a programming assignment, and students submit their solutions to the ITS. The ITS then automatically fixes the student\u2019s code if it is incorrect and elaborates on the fixes to provide high-level feedback as hints, gradually guiding the student to understand the foundational reason for the error. Additionally, the ITS provides a grading support system that automatically grades student submissions for lecturers.</p> <p>This website provides detailed documentation of the ITS, including</p> <ul> <li>Demo Usage</li> <li>API Documentation</li> <li>Overview of the system architecture</li> <li>Detailed features of the system</li> <li>Illustration of the system components.</li> </ul> <p>This documentation is intended for students, lecturers, and developers who are interested in using the ITS for their programming courses. Please reach out if you are interested in collaborating with us or have any questions about the system.</p>"},{"location":"ack.html","title":"Acknowledgement","text":"<p>We thank for all contributors who have contributed to implement the Intelligent Tutoring System, including,</p> <p>FYP Students in Academic Year 2021 -- 2022</p> <p>Kishore R Ai Guo Jon Chua</p> <p>FYP Students in Academic Year 2022 -- 2023</p> <p>Christopher Goh Huang Zhenxin Eris Jacey Masagaca Ethan Noah Rozario</p> <p>All CS3213 Students in Academic Year 2021 -- 2023</p> <p>We thank for relevant research that makes Intelligent Tutoring System become a reality.</p> <p>Verifix: Verified repair of programming assignments Automated Clustering and Program Repair for Introductory Programming Assignments Search, Align, and Repair: Data-Driven Feedback Generation for Introductory Programming Exercises Refactory: Re-factoring based Program Repair applied to Programming Assignments Concept-based Automated Grading of CS-1 Programming Assignments</p> <p>We thank for the funding supported by a Singapore Ministry of Education (MoE) Tier 3 grant \"Automated Program Repair\", MOE-MOET32021-0001.</p>"},{"location":"contact.html","title":"Contact Us","text":"Abhik Roychoudhury Provost\u2019s Chair Professor, NUS <p>Abhik Roychoudhury is a Provost's Chair Professor of Computer Science at the National University of Singapore. Prof Abhik's research focuses on software testing and analysis, software security and trust-worthy software construction. His research on automatically repairing programs at a large scale contributes to the vision of self-healing software. His research team is known for contributions to program repair, and fuzz testing.</p> Zhiyu Fan PhD Candidate, NUS <p>Zhiyu Fan is a final year PhD candidate in the School of Computing at the National University of Singapore, advised by Prof. Abhik Roychoudhury. He is broadly interest in Software Engineering and Generative AI, his research has been focused on the intersections of automated program repair, automatic programming, and computer science education. His has led the development of Intelligent Tutoring System to boost Computer Science education at scale via SE and LLM techniques, which has been deployed in NUS.</p> <p>If you are a researcher or teaching staff at a university and are interested in adopting our resources for your teaching purpose, please get in touch with {abhik,zhiyufan}@comp.nus.edu.sg.</p>"},{"location":"ip.html","title":"Intellectual Property","text":"<p>The Intelligent Tutoring System is registered under the license of National University of Singapore</p> <p>Please refer to https://tech.nus.edu.sg/product/231</p>"},{"location":"courses/cs1010s/intro.html","title":"Introduction","text":"<p>This section describes how Intelligent Tutoring System is being deployed the first-year programming course CS1010S Programming Methodology in NUS School of Computing.</p>"},{"location":"courses/cs1010s/intro.html#teaching-platform","title":"Teaching Platform","text":""},{"location":"courses/cs1010s/intro.html#web-browser-plugin","title":"Web Browser Plugin","text":""},{"location":"courses/cs1010s/intro.html#discord-group-teaching-bot","title":"Discord Group Teaching Bot","text":""},{"location":"courses/cs3213/intro.html","title":"Introduction to CS3213-FSE","text":"<p>This module provides the students with foundational knowledge and understanding of different aspects of software engineering, including requirements, modeling, architecture, behavior, environment, software analysis, validation, and verification. It serves as a second software engineering module exposing the students to the mathematical foundations of software engineering while simultaneously supplementing and elaborating the foundations in a semester-long project.</p>"},{"location":"courses/cs3213/intro.html#teaching-team","title":"Teaching team","text":"<p>Lecturer: Abhik Roychoudhury Co-Lecturer: Yannic Noller Tutors:</p> <ul> <li>AY 2021/2022: Zhiyu Fan, Kishore R, Jon Chua, Guo Ai</li> <li>AY 2022/2023: Zhiyu Fan, Huang Zhenxin, Christopher Goh, Eris Jacey Masagaca, Ethan Noah Rozario</li> </ul>"},{"location":"courses/cs3213/intro.html#material-uploaded","title":"Material Uploaded","text":"<p>All lecture materials for CS3213 (AY 2021/2022) have been uploaded; if you are interested in the resource, please check Lecture and Lecture (Project). Furthermore, we provide material for our semester-long project: a brief overview, the workflow through the framework, and the current project topics that are available to the CS3213 students.</p>"},{"location":"courses/cs3213/intro.html#assessment-weightage","title":"Assessment Weightage","text":"<ul> <li>Project: 45%</li> <li>Final Assessment: 40%</li> <li>Midterm Assessment: 15%</li> </ul>"},{"location":"courses/cs3213/lecture.html","title":"CS3213 Lecture Material","text":""},{"location":"courses/cs3213/lecture.html#lecture-1-introduction","title":"Lecture 1: Introduction","text":"<p>slides 1, slides 2, recording</p> <p>In this lecture, we introduced the foundations and the project in this course. Additionally, we introduced the field of \"requirements engineering\".</p>"},{"location":"courses/cs3213/lecture.html#lecture-2-uml","title":"Lecture 2: UML","text":"<p>slides, recording (part 1), recording (part 2) </p> <p>In this lecture, we discussed UML semantics, including sequence diagram based formal modeling of the system description beyond scenarios.</p>"},{"location":"courses/cs3213/lecture.html#lecture-3-state-charts","title":"Lecture 3: State Charts","text":"<p>slides, recording</p> <p>In this lecture, we described the nuances of state chart semantics.</p>"},{"location":"courses/cs3213/lecture.html#lecture-4-intelligent-tutoring-system","title":"Lecture 4: Intelligent Tutoring System","text":"<p>slides, recording (part 1), recording (part 2), recording (part 2)</p> <p>In this lecture, we gave an idea of the area behind the course project - Intelligent tutoring systems. We discussed the general topic, available tools, involved technical challenges, and the feedback issue in intelligent tutoring.</p>"},{"location":"courses/cs3213/lecture.html#lecture-5-static-analysis-part-1-motivation","title":"Lecture 5: Static Analysis (Part 1 Motivation)","text":"<p>slides, recording </p> <p>In this lecture, we discussed program representations such as the Control Flow Graph (CFG).</p>"},{"location":"courses/cs3213/lecture.html#lecture-6-static-analysis-part-2-program-representation","title":"Lecture 6: Static Analysis (Part 2 Program Representation)","text":"<p>slides, recording</p> <p>In this lecture, we covered simpler descriptin of static program analysis based on data-flow analysis.</p>"},{"location":"courses/cs3213/lecture.html#lecture-7-white-box-testing-test-suite-estimation","title":"Lecture 7: White-box Testing / Test suite estimation","text":"<p>slides, recording </p> <p>In this lecture, we discussed white box testing and test-suite estimation.</p>"},{"location":"courses/cs3213/lecture.html#lecture-8-mid-term","title":"Lecture 8: Mid-term","text":""},{"location":"courses/cs3213/lecture.html#lecture-9-debugging","title":"Lecture 9: Debugging","text":"<p>slides, recording</p> <p>In this lecture, we continued with our discussions on testing and analysis. Some background material on software debugging was presented, including slicing and fault localisation.</p>"},{"location":"courses/cs3213/lecture.html#lecture-10-non-functional-issues-security-and-timeliness","title":"Lecture 10: Non-functional issues: Security and Timeliness","text":"<p>slides 1, slides 2, recording </p> <p>In this lecture, we discussed software performance issues and timing-critical software design.</p>"},{"location":"courses/cs3213/lecture.html#lecture-11-invitation-talks","title":"Lecture 11: Invitation Talks","text":"<p>slides</p> <p>In this lecture, we had two talks on emerging research topics in automated programming by Dr. Sumit Gulwani and Professor Ilya Sergey.</p>"},{"location":"courses/cs3213/lecture.html#lecture-12-revision-of-topics","title":"Lecture 12: Revision of topics","text":"<p>slides, recording</p> <p>In this lecture, we first continued our discussion on sofware performance aspects, and then recapped previous course topics with some warm-up exercises.</p>"},{"location":"courses/cs3213/lecture_p.html","title":"CS3213 Lecture (Project Part)","text":""},{"location":"courses/cs3213/lecture_p.html#lecture-1-introduction-to-course-project","title":"Lecture 1: Introduction to Course Project","text":"<p>slides</p> <p>In Lecture 1, we introduced the idea and topic of our course projects and explained the logistics of our lab session. Furthermore, we introduced the basics of requirements and their elicitation, as needed for Lecture 2.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-2-requirements-elicitation","title":"Lecture 2: Requirements Elicitation","text":"<p>slides</p> <p>In Lecture 2, we performed a live requirements elicitation section with real stakeholders of our overall project. The students prepared questions in advance and interviewed the customers.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-3-requirements-modeling","title":"Lecture 3: Requirements Modeling","text":"<p>slides</p> <p>In Lecture 3, we discussed the requirements elicitation session performed in Lecture 2 and further discussed the resulting requirements models submitted by the students. We provided a general introduction to software architecture to set foot in the solution space.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-4-architecture","title":"Lecture 4: Architecture","text":"<p>slides</p> <p>In Lecture 4, we provided more information on the existing architecture of our project's framework and illustrated several architectural styles.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-5-design-planning","title":"Lecture 5: Design Planning","text":"<p>slides</p> <p>In Lecture 5, we discussed aspects of the module design for each project and introduced essential parts of our baseline implementation as the internal program representation. We further discussed the basics of project planning.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-6-testing","title":"Lecture 6: Testing","text":"<p>slides</p> <p>In Lecture 6, we discussed the basics of software testing and introduced concepts like equivalence class partitioning and unit testing.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-7-advanced-testing","title":"Lecture 7: Advanced Testing","text":"<p>slides</p> <p>In Lecture 7, we intensified the knowledge from Lecture 6 about software testing. We discussed aspects of testable code and test-driven development. We further started introducing the foundations of debugging.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-8-debugging","title":"Lecture 8: Debugging","text":"<p>slides</p> <p>In Lecture 8, we investigated more debugging approaches and introduced concepts like TRAFFIC, dynamic and static slicing, and statistical fault localization.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-9-static-analysis","title":"Lecture 9: Static Analysis","text":"<p>slides</p> <p>In Lecture 9, we provided more examples for program slicing and gave a practical introduction to static analysis.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-10-implementation","title":"Lecture 10: Implementation","text":"<p>slides</p> <p>In Lecture 10, we discussed implementation aspects and introduced several notions of clean code.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-11-integration","title":"Lecture 11: Integration","text":"<p>slides</p> <p>In Lecture 11, we discussed typical problems with software integration and introduced integration strategies and testing concepts.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-12-summary","title":"Lecture 12: Summary","text":"<p>slides</p> <p>In Lecture 12, we recaped all discussed topics and provided a summary for all project-parts of the lecture.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-13-final-project-presentations","title":"Lecture 13: Final Project Presentations","text":"<p>slides</p> <p>In Lecture 13, every student group presented their final outcome and demonstrated their contributions.</p>"},{"location":"courses/cs3213/project/intro.html","title":"Overview","text":""},{"location":"courses/cs3213/project/intro.html#intelligent-tutoring-system","title":"Intelligent Tutoring System","text":"<p>The high-level idea of the Intelligent Tutoring System is to introduce an automated technique to provide feedback and grading suggestions for programming assignments. As shown in the above figure, for a given programming assignment, the tutor would provide a reference solution and some test cases, while the student would submit a solution and receive feedback. The feedback should go beyond the simple execution of test cases and tell the student where and how to fix the submission. More sophisticated and gradual ways of feedback could also be introduced.</p>"},{"location":"courses/cs3213/project/topics.html","title":"Topics","text":"<p>Developing such an Intelligent Tutoring System (ITS) includes many conceptual and technical challenges. We summarized some of them into projects, from which the students in CS3213 need to choose one as a group project. Please find below the project summaries as proposed for the students in CS3213 (NUS AY 2021/2022). We group projects by their provided functionalities. Each project has assigned estimated difficulty levels (Low, Medium, High) in the categories: coding (i.e., programming intensity), theoretical complexity (i.e., need for background study), amount of research involved (i.e., be innovative and create something new), and the involvement of HCI (Human-Computer Interaction) aspects.</p> <p>More details can be found in our Assignment 0.</p>"},{"location":"courses/cs3213/project/topics.html#topic-1-parsing","title":"Topic 1 - Parsing","text":"<p>Project 1.1 C Parser: Develop a parser to transform C programs into a (provided) common data structure based on the control-flow graph (CFG). Additionally, provide a concretizer, which back-transforms the program in the internal common data structure to a C source file. \u2192 [Coding: High, Theory: Low, Research: -, HCI: -]</p> <p>Project 1.2 Python Parser: Same as 1.1 for Python. \u2192 [Coding: High, Theory: Low, Research: -, HCI: -]</p>"},{"location":"courses/cs3213/project/topics.html#topic-2-aligning-matching-of-programs","title":"Topic 2 \u2013 Aligning / Matching of Programs","text":"<p>Project 2.1 CFG-Based Alignment: Develop an automated alignment of the reference program and the submitted program based on the basic blocks of the programs\u2019 control-flow graph (CFG) representation. This also includes the development of an automated mapping for the variables between the reference program and the submitted program. \u2192 [Coding: Medium, Theory: Medium, Research: Low, HCI: -]</p>"},{"location":"courses/cs3213/project/topics.html#topic-3-error-localization-program-interpretation","title":"Topic 3 \u2013 Error Localization / Program Interpretation","text":"<p>Project 3.1 C Interpreter:  Develop an interpreter that allows to execute a C program with regard to the basic blocks in its CFG. Further, use the provided test cases to identify the root cause of the problem with regard to the basic blocks in the CFG. Implement an error localization that compares the execution traces of a reference program and the submitted program. \u2192 [Coding: High, Theory: Medium, Research: -, HCI: -]</p> <p>Project 3.2 Python Interpreter: same as 3.1 for Python \u2192 [Coding: High, Theory: Medium, Research: -, HCI: -]</p> <p>Project 3.3 Error Localizer: Conduct a literature study on error localization. Develop at least two error localization algorithms from different domains (e.g., statistical fault localization and analysis-based fault localization) for the provided framework and evaluate their efficacy.  \u2192 [Coding: Medium, Theory: High, Research: Low, HCI: -]</p>"},{"location":"courses/cs3213/project/topics.html#topic-4-transforming-repairing-programs","title":"Topic 4 \u2013 Transforming / Repairing Programs","text":"<p>Project 4.1 Refactoring-based Repair: Develop a repair workflow that first generates semantic-preserving refactorings of a reference program so that it increases the chances of a structural alignment with a submitted program (see Project 2.1). Afterwards, it uses a matching refactoring to repair the submitted program by mutating program expressions. Strive for a minimal repair which satisfies the failing test case(s). \u2192 [Coding: Medium, Theory: Medium, Research: Medium, HCI: -]</p> <p>Project 4.2 Optimization-based Repair: Develop a repair algorithm that (1) generates local repairs at each basic block by matching the submission and the reference solution, and (2) determines the complete repair (i.e., a subset of local repairs) by using some optimization strategy, which minimizes the overall repair cost. \u2192 [Coding: Medium-High, Theory: High, Research: Low, HCI: -]</p> <p>Project 4.3 Synthesis-based Repair: Develop a repair algorithm that searches for a repair by synthesizing program expressions. The synthesis will be driven by the available components at the specific source location. It requires a specification inference, which results in a repair constraint. \u2192 [Coding: Medium, Theory: High, Research: Medium, HCI: -]</p>"},{"location":"courses/cs3213/project/topics.html#topic-5-feedback-generation","title":"Topic 5 \u2013 Feedback Generation","text":"<p>Project 5.1 Automated Feedback: Develop a feedback mechanism to summarize all obtained results in an appropriate and comprehensible manner for the user. For example, show root causes of the problems and provide explanation by annotating the code. \u2192 [Coding: Low, Theory: Medium, Research: Medium, HCI: High]</p> <p>Project 5.2 Automated Grading: Develop a automated grading mechanism, which is beyond simple output of passing and failing test cases, e.g., it should take into account the necessary effort for fixing the submitted program. \u2192 [Coding: Low, Theory: High, Research: High, HCI: Low]</p>"},{"location":"courses/cs3213/project/workflow.html","title":"Workflow","text":"<p>The following steps show the intended workflow through the Intelligent Tutoring System (ITS). Note that there are points of variation (static and dynamic) that depend, e.g., on the programming language of the programming assignments and the intended repair strategies. Many of the current components can be implemented in many different ways.</p>"},{"location":"courses/cs3213/project/workflow.html#overview","title":"Overview","text":"<p>The Intelligent Tutoring System (ITS) uses the notion of a pipes-and-filter style to process the submitted program and, finally, to produce feedback for the students and a grading report for the tutor.</p> <p>All components provide corresponding interfaces to the extent that most components can be implemented independently from each other.</p> <p>This architecture also allows us to deploy specific system components as separate services. In this regard, the design borrows concepts from the service-oriented style. For example, we provide students with access to a Parser service that allows them to easily generate the internal CFG-based Program representation to create test cases for their projects.</p>"},{"location":"courses/cs3213/project/workflow.html#step-1-parser","title":"Step 1: Parser","text":""},{"location":"courses/cs3213/project/workflow.html#step-2-syntactic-alignment","title":"Step 2: Syntactic Alignment","text":""},{"location":"courses/cs3213/project/workflow.html#step-3-error-localizer","title":"Step 3: Error Localizer","text":""},{"location":"courses/cs3213/project/workflow.html#step-4-interpreter","title":"Step 4: Interpreter","text":""},{"location":"courses/cs3213/project/workflow.html#step-5-repair","title":"Step 5: Repair","text":""},{"location":"courses/cs3213/project/workflow.html#step-6-feedback","title":"Step 6: Feedback","text":""},{"location":"courses/cs3213/project/workflow.html#step-7-concretization","title":"Step 7: Concretization","text":""},{"location":"courses/cs3213/project/workflow.html#step-8-auto-grading","title":"Step 8: Auto-Grading","text":""},{"location":"documentation/components.html","title":"Components in Intelligent Tutoring System","text":""},{"location":"documentation/components.html#parser","title":"Parser","text":""},{"location":"documentation/components.html#alignment","title":"Alignment","text":""},{"location":"documentation/components.html#error-localizer-and-interpreter","title":"Error Localizer and Interpreter","text":""},{"location":"documentation/components.html#repair-engines","title":"Repair Engines","text":""},{"location":"documentation/components.html#feedback-generators","title":"Feedback Generators","text":""},{"location":"documentation/components.html#automated-grader","title":"Automated Grader","text":""},{"location":"documentation/overview.html","title":"Overview","text":"Figure 1: Overview of the workflow of the Intelligent Tutoring System."},{"location":"getting-started/usage.html","title":"Demo Usage","text":""},{"location":"getting-started/usage.html#example-programming-assignment","title":"Example Programming Assignment","text":"<p>Let's consider a simple programming assignment where students are asked to write a C program that calculates the sum of the first <code>n</code> natural numbers. The program should take an integer <code>n</code> as input and output the sum of the first <code>n</code> natural numbers. </p> <pre><code>#Reference Solution from Instructor \n#include &lt;stdio.h&gt;\nint main(){\n  int i,j,n,sum=0;\n  scanf(\"%d\",&amp;n);  \n  for(i=1;i&lt;=n;i++){\n    for(j=1;j&lt;=i;j++){\n      sum+=j;\n    }\n  }\n  printf(\"%d\",sum);\n  return 0;\n}    \n</code></pre> <pre><code>#Example Student Submission (Incorrect)\n#include &lt;stdio.h&gt;\nint main(){\n  int i,j,N,sum;\n  sum=0;\n  scanf(\"%d\",&amp;N);\n  for(i=1;i&lt;=N;i++){\n    for(j=1;j&lt;=N;j++){ &lt;== Incorrect loop condition\n      sum=sum+j;\n    }\n  }\n  printf(\"%d\",sum);\n  return 0;\n} \n</code></pre>"}]}