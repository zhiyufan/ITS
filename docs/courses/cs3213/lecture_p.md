# CS3213 Lecture (Project Part)

## Lecture 1: Introduction to Course Project
[slides](slides/lectures-project/Project_01_Intro.pdf)

In Lecture 1, we introduced the idea and topic of our course projects and explained the logistics of our lab session. Furthermore, we introduced the basics of requirements and their elicitation, as needed for Lecture 2.


## Lecture 2: Requirements Elicitation
[slides](slides/lectures-project/Project_02_RequirementsElicitation.pdf)

In Lecture 2, we performed a live requirements elicitation section with real stakeholders of our overall project. The students prepared questions in advance and interviewed the customers.


## Lecture 3: Requirements Modeling
[slides](slides/lectures-project/Project_03_RequirementsModeling.pdf)

In Lecture 3, we discussed the requirements elicitation session performed in Lecture 2 and further discussed the resulting requirements models submitted by the students. We provided a general introduction to software architecture to set foot in the solution space.


## Lecture 4: Architecture 
[slides](slides/lectures-project/Project_04_Architecture.pdf)

In Lecture 4, we provided more information on the existing architecture of our project's framework and illustrated several architectural styles.


## Lecture 5: Design Planning
[slides](slides/lectures-project/Project_05_Design_Planning.pdf)

In Lecture 5, we discussed aspects of the module design for each project and introduced essential parts of our baseline implementation as the internal program representation. We further discussed the basics of project planning.


## Lecture 6: Testing
[slides](slides/lectures-project/Project_06_Testing.pdf)

In Lecture 6, we discussed the basics of software testing and introduced concepts like equivalence class partitioning and unit testing.


## Lecture 7: Advanced Testing
[slides](slides/lectures-project/Project_07_Advanced_Testing.pdf)

In Lecture 7, we intensified the knowledge from Lecture 6 about software testing. We discussed aspects of testable code and test-driven development. We further started introducing the foundations of debugging.


## Lecture 8: Debugging
[slides](slides/lectures-project/Project_08_Debugging.pdf)

In Lecture 8, we investigated more debugging approaches and introduced concepts like TRAFFIC, dynamic and static slicing, and statistical fault localization.


## Lecture 9: Static Analysis
[slides](slides/lectures-project/Project_09_StaticAnalysis.pdf)

In Lecture 9, we provided more examples for program slicing and gave a practical introduction to static analysis.


## Lecture 10: Implementation
[slides](slides/lectures-project/Project_10_Implementation.pdf)

In Lecture 10, we discussed implementation aspects and introduced several notions of clean code.


## Lecture 11: Integration
[slides](slides/lectures-project/Project_11_Integration.pdf)

In Lecture 11, we discussed typical problems with software integration and introduced integration strategies and testing concepts.


## Lecture 12: Summary
[slides](slides/lectures-project/Project_12_Summary.pdf)

In Lecture 12, we recaped all discussed topics and provided a summary for all project-parts of the lecture.


## Lecture 13: Final Project Presentations
[slides](slides/lectures-project/Project_13_Presentations_Schedule.pdf)

In Lecture 13, every student group presented their final outcome and demonstrated their contributions.

